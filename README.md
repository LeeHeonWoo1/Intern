### 경쟁사 관리 업무 자동화 프로그램(2/27~)
- 경쟁사 관리 업무의 단순 반복 과정을 줄이고자 진행한 프로그래밍
- 대형제조사(약 60여개) 홈페이지를 하나하나씩 살펴보면서 검색엔진이 잘 구축된 사이트를 발굴하는게 우선
- 이후 각 제조사별로 크롤링하는 코드만 수정하는 방향으로 프로젝트 진행

### 사용언어
- Python

### 사용한 주요 라이브러리
- selenium, tkinter, requests, PyPDF2 -> pdfminer
- 크롤링을 위한 selenium과 GUI프로그래밍을 위한 tkinter, pdf를 다운받을 때 필요했던 request
- 크롤링한 파트넘버와 PDF파일 안의 파트넘버를 비교하기 위해 사용했던 PyPDF2 -> 이후 pdfminer로 변경
- 그 외엔 progress bar를 대체할 수 있었던 tqdm이라던가 웹 엘리먼트들을 찾기 위해 time을 사용

### Project flow
#### 크롤링파트
1. 제조사 별로 홈페이지에서 파트넘버와 PDF파일 링크들을 크롤링
2. 모아진 데이터들은 회사 내부 페이지인 master페이지의 중복검사 탭에서 중복검사를 실시
 + 2-1. 크롤링된 데이터들은 csv파일로 전환
 + 2-2. 이 때 서버 과부화를 생각해서 페이지 별 csv파일과 병합본 csv파일을 따로 생성
3. 중복검사 결과를 병합본 csv파일에 입력
4. 중복되지 않는 파트넘버들에 한해서만 PDF다운로드 진행
5. pdf안의 파트넘버와 크롤링한 파트넘버를 대조해서 이름이 같으면 작업파일로 이동
6. 남겨진 파일들에 대해 pdf안의 파트넘버로 2차 중복검사 실시
7. 2차 중복검사 결과 중복되는 파일들은 삭제, 아닌 파일들은 파일이름을 변경하고 작업파일로 이동

#### GUI파트
1. 메인화면 생성
2. 프레임 분할(header, main)
3. header에 들어갈 문구 작성
4. main에 들어갈 버튼, 엔트리 생성 후 pack
5. 하단의 남는 공간을 이용해서 간단 사용설명서 작성

### 한계점
1. 각 제조사 별 파트넘버 및 PDF링크 크롤링 시에 발생하는 이슈
- 어떤 제조사는 test PDF파일들을 그냥 올려놓고서 삭제를 하지 않는다던가, 업로드 해야하는 유형의 PDF와는 거리가 있는 내용의 PDF파일이 존재하는 곳도 있었다.
- 이 정도는 유형이 많지 않기에 간단하진 않았지만 예외처리 할 수 있었으나, 제일 큰 한계는 아래의 2번이었다.

2. 각 제조사 별 파트넘버 유형이 너무 상이함
- 한 PDF가 두 개 이상의 파트넘버를 지칭하는 경우 ABX122-ABX124 식으로 표기하는 방식을 모든 제조사가 동일하게 채택하면 모르겠으나
- 어떤 제조사는 -으로 묶고, 어떤 제조사는 _로 묶고 어떤 제조사는 그냥 붙여버리는 경우도 있으며 파일 저장시에 문제가 되는 /로 묶는 제조사도 존재
- 영어와 숫자 조합에서 영어는 동일하고 숫자만 다른 경우는 영어를 생략하고 숫자만 작성하는 경우도 존재했다.
- 파트넘버가 아니라 문서번호로 저장하는 제조사도 존재했음.
- 아래는 예외처리해야 했던 '일부'의 예시이다.

***
STRATEGIC 제거, TTSOP 제거, RECTIFIERSTACKS 제거, TERMINATOR 제거, BACKOFFDIODES 제거, COMPENSATION 제거, D1213A로 시작하는 파트넘버들은 하이픈 자르지 않을 것<br>
분할대상 => PT8A32223298ADE2, PT8A9701973973L2, PT8A977B978B978BL2, D24V0S1U2LP1610Q, D36V0S1U2LP1610Q, D3V3S1U2LP1610Q, 추가로 문자열 길이 대조해서 긴것들도 자르기
***

3. pdf자료 구조의 다양성
- pdf의 일부분을 잘라서 해당 부분에서만 텍스트를 추출하면 pdf안의 글자들을 읽어 파트넘버를 찾을 때 좀 더 정확하게 찾을 수 있지 않을까 싶은 생각도 있었으나 파트넘버의 위치가 pdf의 자료 유형에 따라 다 달라서 위치를 특정할 수 없을 뿐더러 2번에서 언급했듯 pdf안에 파트넘버가 아니라 문서번호가 들어가있다면 이 또한 이후의 작업에서 문제점이 발생한다.

### 정확성을 높이기 위해 시도했던 요소들
1. 모듈 변경
- pypdf2의 경우 상대적으로 간단한 코드로 pdf파일을 읽을 수 있었기에 간편했으나, eof marker not found issue로 인해 pdfminer로 시도했음. <br>
=> 두 모듈 다 pdf안의 첫 페이지의 모든 글자를 추출해 파트넘버에 자꾸 다른 글자들이 섞여 들어가서 크게 의미는 없는듯했다.

2. pdf안의 파트넘버가 있는 위치를 잘라서 읽어오기
- 아래의 두 가지 방법은 pdf안의 글자를 추출할 때 파트넘버가 제대로 추출되지 않아 시도했던 내용이다. <br>
 + 2-1. pytesseract : ocr을 사용하기 위해, 이미지화 된 pdf파일에 파트넘버가 있는 장소를 opencv로 잘라서 추출하려 했으나, 시간이 오래걸리는 편이어서 포기했다
 + 2-2. PyPDF2 : EOF marker not found error를 감수하고서라도 구역을 제한해 글자를 추출하는게 가능한 모듈이기에 우측 상단을 기준으로 글자를 추출하려 했으나 아래의 사유로 인해 포기. <br>
  + 2-2-1. pdf형식의 다양성 : pdf형식이 한 제조사 안에만 해도 경우의 수가 많아 오른쪽 위를 특정지어 추출하기엔 제대로된 글자를 긁을 수 없었다(파트넘버가 없기도 하고, 문서번호가 들어가있기도 하며, 파트넘버가 있음에도 읽지 못하는 현상도 발견).
  + 2-2-2. 특정 제조사의 한계 : NXP제조사의 경우 우측 상단에 문서번호가 들어가는 경우가 있고, 만약 그 pdf가 홈페이지에 문서번호를 제목으로 등록되어 있던 pdf라면 파일이름이 저장될 때 파트넘버 이름으로 저장되는게 아니라 문서번호로 저장이 되기에 업로드 시 문제가 발생할 수 있다.

3. 머신러닝이나 딥러닝으로는 해결할 수 없는가?
- 아직까지 지식이 확립되지 않은 분야라 이것저것 많이 찾아보았지만 데이터 구성부터 전처리, 모델링까지의 전체적인 그림이 잘 그려지지 않아 포기

### 사용 방향성
1. 파트넘버 수집
2. 1차 중복검사
3. 일단 중복되지 않는 것들만 다운로드
4. 파일 분리
5. 'PDF'파일에 남은 pdf는 업로드 시 사람이 한 번더 확인
6. 만약 pdf안의 파트넘버와 파일이름에 있는 파트넘버가 다르다면 사람이 직접 중복검사 한 번더 실시
7. 그래도 중복되지 않는 파일이라면 파일이름 변경 후 업로드

### 마무리하며..
- 본래 계획했던 목표치까지 이루지 못해 아쉬운 마음이 제일 큰 것 같다. 아직까지 개발 실력이 부족하기도 하고 마땅히 좋은 방안이 생각나지 않아 되려 시간낭비를 하거나 쓸모없는 일을 하지 않았을까 하는 생각도 많이 들었다. 그래도 이전에 썼던 것들을 다시 써보면서 확실하게 알아가는 것도 생기고, 이전에 해보지 않았던 새로운 것들도 많이 알게 되었으며 개발 기획은 좀 더 신중하게 해야겠다는 생각도 많이 들었던 것 같다.
